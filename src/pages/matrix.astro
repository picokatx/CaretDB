---
// Use the new Layout component
import Layout from "../components/Layout.astro";
import "../styles/rrweb-player.css";
const systemName = "ClickstreamDB";
---

<Layout title={`${systemName} - Local Record & Replay`}>
  <h1 class="text-2xl font-bold mb-4">
    RRWeb Local Record & Replay (Iframe Managed)
  </h1>

  <!-- HTML Upload/Paste Section -->
  <div class="mb-6 bg-base-200 p-4 rounded-box">
    <h2 class="text-xl font-semibold mb-3">Custom Content</h2>

    <div class="flex flex-col md:flex-row gap-4">
      <!-- File Upload Area -->
      <div class="flex-1">
        <h3 class="font-medium mb-2">Upload HTML File</h3>
        <label
          class="flex flex-col items-center justify-center w-full h-32 border-2 border-dashed rounded-lg cursor-pointer hover:bg-base-300 bg-base-100 border-base-300"
        >
          <div class="flex flex-col items-center justify-center">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="w-8 h-8 text-primary"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
              ></path>
            </svg>
            <p class="mt-2 text-sm text-center">
              <span class="font-semibold">Click to upload</span> or drag and drop
            </p>
            <p class="text-xs text-base-content/60">HTML files only</p>
          </div>
          <input
            type="file"
            class="hidden"
            accept=".html,.htm"
            id="html-file-input"
          />
        </label>
        <div class="flex justify-end mt-2">
          <button class="btn btn-sm btn-primary" id="upload-html-btn"
            >Upload</button
          >
        </div>
      </div>

      <!-- HTML Paste Area -->
      <div class="flex-1">
        <h3 class="font-medium mb-2">Paste HTML Content</h3>
        <div class="flex flex-col h-full">
          <textarea
            class="textarea textarea-bordered flex-grow h-32 w-full"
            placeholder="Paste HTML content here..."
            id="html-content-input"></textarea>
          <div class="flex justify-end mt-2">
            <button class="btn btn-sm btn-primary" id="load-html-btn"
              >Load Content</button
            >
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="flex flex-col md:flex-row gap-4">
    <!-- Recording Area -->
    <div class="flex-1">
      <h2 class="text-xl font-semibold mb-2">
        Recording Window (Local Content)
      </h2>
      <p class="mb-2 text-info bg-base-200 p-2 rounded text-sm">
        Interact with the content below. Recording is managed within the iframe.
      </p>
      <div class="mockup-browser border bg-base-300">
        <div class="mockup-browser-toolbar">
          <div class="input">/dom/recordable-page.html</div>
        </div>
        <div class="flex justify-center bg-base-200">
          <iframe
            id="record-frame"
            src="/dom/recordable-page.html"
            width="95%"
            height="400px"
            class="border border-neutral my-4"></iframe>
        </div>
      </div>
    </div>

    <!-- Replay Area -->
    <div class="flex-1">
      <h2 class="text-xl font-semibold mb-2">Replay Window</h2>
      <p class="mb-2 text-info bg-base-200 p-2 rounded text-sm">
        Recorded session will replay here after you stop recording.
      </p>
      <div class="mockup-browser border bg-base-300">
        <div class="mockup-browser-toolbar">
          <div class="input">Replay Area</div>
        </div>
        <div
          id="replay-container"
          class="flex justify-center items-center bg-base-200 min-h-[436px]"
        >
          {/* rrweb-player will attach here */}
        </div>
      </div>
    </div>
  </div>

  <!-- Controls -->
  <div class="mt-4 flex items-center gap-4">
    <button id="start-record-btn" class="btn btn-success"
      >Start Recording</button
    >
    <!-- Always enabled -->
    <button id="stop-replay-btn" class="btn btn-error" disabled
      >Stop Recording & Replay</button
    >
    <p id="status" class="font-semibold">Status: Idle</p>
  </div>

  <!-- Timeline Panel -->
  <div
    id="timeline-panel"
    class="mt-8 border border-base-300 rounded-box bg-base-100 shadow-sm overflow-hidden"
  >
    <div
      class="px-4 py-3 border-b border-base-200 flex justify-between items-center"
    >
      <h3 class="font-bold text-lg">Replay Timeline</h3>
      <div class="flex gap-2">
        <div class="tabs tabs-boxed">
          <button
            id="timeline-view-btn"
            class="tab tab-active bg-primary text-primary-content"
            >Timeline</button
          >
          <button id="console-view-btn" class="tab">Console Logs</button>
          <button id="network-view-btn" class="tab">Network</button>
          <button id="raw-view-btn" class="tab">Raw JSON</button>
        </div>
        <button id="json-copy-btn" class="btn btn-sm btn-outline"
          >Copy JSON</button
        >
      </div>
    </div>

    <div class="p-4">
      <!-- Raw JSON View -->
      <div id="raw-json-view" class="hidden">
        <pre
          id="json-content"
          class="bg-base-300 p-4 rounded-box overflow-auto max-h-[50vh] text-xs">
        </pre>
      </div>

      <!-- Console Logs View -->
      <div id="console-logs-view" class="hidden">
        <div class="flex items-center gap-2 mb-4">
          <div class="dropdown dropdown-hover">
            <label tabindex="0" id="log-level-display" class="btn btn-sm"
              >Log Level: Any</label
            >
            <ul
              tabindex="0"
              class="dropdown-content z-[1] menu p-2 shadow bg-base-200 rounded-box w-52"
            >
              <li>
                <a class="log-level-filter active" data-level="any">Any</a>
              </li>
              <li><a class="log-level-filter" data-level="log">Log</a></li>
              <li><a class="log-level-filter" data-level="info">Info</a></li>
              <li><a class="log-level-filter" data-level="warn">Warn</a></li>
              <li><a class="log-level-filter" data-level="error">Error</a></li>
            </ul>
          </div>
          <div class="form-control flex-1">
            <div class="input-group">
              <input
                id="console-search"
                type="text"
                placeholder="Search Console Logs"
                class="input input-bordered input-sm w-full"
              />
              <button id="console-search-btn" class="btn btn-sm btn-square">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-4 w-4"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                  ><path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg
                >
              </button>
            </div>
          </div>
        </div>
        <div
          id="console-timeline"
          class="bg-base-300 rounded-box overflow-auto max-h-[50vh] p-0"
        >
          <div class="p-4 text-center text-base-content/60">
            No console logs recorded yet
          </div>
        </div>
        <div class="mt-4 flex justify-center">
          <button id="jump-to-current-timestamp" class="btn btn-sm btn-primary">
            Jump to current timestamp
          </button>
        </div>
      </div>

      <!-- Network Requests View -->
      <div id="network-requests-view" class="hidden">
        <div class="flex items-center gap-2 mb-4">
          <div class="form-control flex-1">
            <div class="input-group">
              <input
                id="network-search"
                type="text"
                placeholder="Search Network Requests"
                class="input input-bordered input-sm w-full"
              />
              <button id="network-search-btn" class="btn btn-sm btn-square">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-4 w-4"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                  ><path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg
                >
              </button>
            </div>
          </div>
        </div>

        <div class="overflow-x-auto">
          <table class="table table-zebra table-compact w-full">
            <thead>
              <tr>
                <th>Path</th>
                <th>Method</th>
                <th>Status</th>
                <th>Type</th>
                <th>Size</th>
                <th>Duration</th>
                <th>Time</th>
              </tr>
            </thead>
            <tbody id="network-timeline">
              <tr>
                <td colspan="7" class="text-center py-4"
                  >No network requests recorded yet</td
                >
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Timeline View -->
      <div id="timeline-view" class="grid grid-cols-1 lg:grid-cols-5 gap-4">
        <!-- Preview panel (2/5 width on large screens) -->
        <div
          class="lg:col-span-2 bg-base-200 rounded-box p-4 flex items-center justify-center min-h-[50vh]"
        >
          <div id="timeline-preview" class="text-center">
            <div
              class="mockup-browser border bg-base-300 w-full max-w-md mx-auto"
            >
              <div class="mockup-browser-toolbar">
                <div class="input">/replay-preview</div>
              </div>
              <div
                class="bg-base-200 p-4 flex flex-col items-center justify-center"
                style="min-height: 300px;"
              >
                <h4 class="text-lg font-semibold mb-4">Replay Preview</h4>
                <p class="text-sm text-base-content/70">
                  Start recording to capture events
                </p>
              </div>
            </div>
          </div>
        </div>

        <!-- Events timeline (3/5 width on large screens) -->
        <div
          class="lg:col-span-3 overflow-auto max-h-[50vh] bg-base-100 rounded-box border border-base-200"
        >
          <div id="event-timeline" class="p-2">
            <div class="p-4 text-center text-base-content/60">
              No events recorded yet
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</Layout>

<script>
  // Import rrweb-player for enhanced playback controls
  import * as rrwebPlayer from "rrweb-player";
  import { EventType, IncrementalSource, MouseInteractions } from "rrweb";
  import {
    formatTimestamp,
    getEventTypeName,
    getIncrementalSourceName,
    getMouseInteractionName,
    initPlayer,
  } from "../lib/matrix/player";
  import {
    createCompactEventDetails,
    createEventDetails,
    selectEvent,
    generateTimelineView,
    getLogLevelClass,
    getLogLevelBadge,
    formatLogLevel,
  } from "../lib/matrix/timeline";
  import { escapeHtml, formatBytes, getFullPath } from "../lib/matrix/console";
  import type { IframeWindowWithRecorder } from "../lib/matrix/recorder";
  import { initRecorder, setupErrorPrevention } from "../lib/matrix/recorder";
  import { updateTabHighlighting } from "../lib/matrix/timeline";
  import { matrixGlobals as mGlob } from "../lib/matrix/globals";

  document.addEventListener("DOMContentLoaded", () => {
    console.log("Parent DOMContentLoaded fired.");
    const recordFrame = document.getElementById(
      "record-frame"
    ) as HTMLIFrameElement | null;
    const replayContainer = document.getElementById("replay-container");
    const startBtn = document.getElementById(
      "start-record-btn"
    ) as HTMLButtonElement | null;
    const stopBtn = document.getElementById(
      "stop-replay-btn"
    ) as HTMLButtonElement | null;
    const timelineViewBtn = document.getElementById("timeline-view-btn");
    const rawViewBtn = document.getElementById("raw-view-btn");
    const consoleViewBtn = document.getElementById("console-view-btn");
    const rawJsonView = document.getElementById("raw-json-view");
    const timelineView = document.getElementById("timeline-view");
    const consoleLogsView = document.getElementById("console-logs-view");
    const eventTimeline = document.getElementById("event-timeline");
    const timelinePreview = document.getElementById("timeline-preview");
    const consoleTimeline = document.getElementById("console-timeline");
    const jsonContent = document.getElementById("json-content");
    const jsonCopyBtn = document.getElementById("json-copy-btn");
    const consoleSearch = document.getElementById(
      "console-search"
    ) as HTMLInputElement;
    const consoleSearchBtn = document.getElementById("console-search-btn");
    const jumpToCurrentBtn = document.getElementById(
      "jump-to-current-timestamp"
    );
    const statusEl = document.getElementById("status");


    if (
      !recordFrame ||
      !replayContainer ||
      !startBtn ||
      !stopBtn ||
      !timelineViewBtn ||
      !rawViewBtn ||
      !rawJsonView ||
      !timelineView ||
      !eventTimeline ||
      !timelinePreview ||
      !jsonContent ||
      !jsonCopyBtn ||
      !consoleViewBtn ||
      !consoleLogsView ||
      !consoleTimeline
    ) {
      console.error(
        "Parent: Essential UI elements not found! Cannot initialize."
      );
      if (statusEl)
        statusEl.textContent = "Status: Error - UI elements missing";
      return;
    }

    const networkViewBtn = document.getElementById("network-view-btn");
    const networkRequestsView = document.getElementById(
      "network-requests-view"
    );
    const networkTimeline = document.getElementById("network-timeline");
    const networkSearch = document.getElementById(
      "network-search"
    ) as HTMLInputElement;
    const networkSearchBtn = document.getElementById("network-search-btn");

    // Generate console logs view
    function updateConsoleLogsView(): void {
      if (!consoleTimeline) return;

      // Filter console logs based on current settings
      const filteredLogs = mGlob.consoleLogs.filter((log) => {
        // Filter by log level if needed
        if (mGlob.currentLogLevel !== "any" && log.level !== mGlob.currentLogLevel) {
          return false;
        }

        // Filter by search text if needed
        if (mGlob.consoleSearchText) {
          const logContent = log.args.join(" ").toLowerCase();
          return logContent.includes(mGlob.consoleSearchText);
        }

        return true;
      });

      // Clear previous content
      consoleTimeline.innerHTML = "";

      if (filteredLogs.length === 0) {
        consoleTimeline.innerHTML =
          '<div class="p-4 text-center text-base-content/60">No matching console logs found</div>';
        return;
      }

      // Use the first event overall (not just console events) as the base timestamp
      const baseTimestamp =
        mGlob.rrwebEvents.length > 0
          ? mGlob.rrwebEvents[0].timestamp
          : mGlob.consoleLogs.length > 0
            ? mGlob.consoleLogs[0].timestamp
            : 0;

      // Create console log items
      filteredLogs.forEach((log) => {
        const logItem = document.createElement("div");

        // Set base class and add level-specific class
        logItem.className =
          "console-log-item border-b border-base-100 p-2 hover:bg-base-200";

        // Get styling based on log level
        const levelClass = getLogLevelClass(log.level || "log");

        // Format the log content
        const logContent = log.args.join(" ");
        const isLongMessage = logContent.length > 100;

        // Format timestamp
        const timestamp = formatTimestamp(log.timestamp, baseTimestamp);

        // Add level badge
        const levelBadge = getLogLevelBadge(log.level || "log");

        // Add warning icon for errors
        let icon = "";
        if (log.level === "error" || log.level === "warn") {
          icon = `<span class="${levelClass} mr-2">⚠</span>`;
        }

        // Create the log item content with collapsible functionality for long messages
        if (isLongMessage) {
          logItem.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="log-content ${levelClass} flex-1 cursor-pointer" data-expanded="false">
                            <div class="flex items-start">
                                ${levelBadge}
                                ${icon}
                                <div class="log-message-container">
                                    <div class="log-message-preview">${escapeHtml(logContent.substring(0, 100))}... <span class="text-primary">[Click to expand]</span></div>
                                    <div class="log-message-full hidden">${escapeHtml(logContent)}</div>
                                </div>
                            </div>
                        </div>
                        <div class="log-timestamp text-xs opacity-70 ml-4 shrink-0 mt-1">
                            ▶ ${timestamp}
                        </div>
                    </div>
                `;

          // Add click handler to expand/collapse with proper TypeScript typing
          const logContentEl = logItem.querySelector(".log-content");
          logContentEl?.addEventListener("click", function (this: HTMLElement) {
            const expanded = this.getAttribute("data-expanded") === "true";
            const preview = this.querySelector(".log-message-preview");
            const full = this.querySelector(".log-message-full");

            if (expanded) {
              // Collapse
              preview?.classList.remove("hidden");
              full?.classList.add("hidden");
              this.setAttribute("data-expanded", "false");
            } else {
              // Expand
              preview?.classList.add("hidden");
              full?.classList.remove("hidden");
              this.setAttribute("data-expanded", "true");
            }
          });
        } else {
          // For short messages, no need for expand/collapse
          logItem.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="log-content ${levelClass}">
                            ${levelBadge}${icon}${escapeHtml(logContent)}
                        </div>
                        <div class="log-timestamp text-xs opacity-70 ml-4 shrink-0">
                            ▶ ${timestamp}
                        </div>
                    </div>
                `;
        }

        // Add click handler to jump to this event in the player
        logItem.addEventListener("click", (e) => {
          // Don't trigger player jump if clicking on the message content (for expand/collapse)
          if ((e.target as HTMLElement).closest(".log-content")) return;

          if (mGlob.playerInstance && typeof mGlob.playerInstance.goto === "function") {
            mGlob.playerInstance.goto(log.timestamp);
          }
        });

        consoleTimeline.appendChild(logItem);
      });
    }

    // Generate network requests view
    function updateNetworkRequestsView(): void {
      if (!networkTimeline) return;

      console.log(
        `Updating network view with ${mGlob.networkRequests.length} requests`
      );

      // Filter network requests based on search text
      const filteredRequests = mGlob.networkRequests.filter((req) => {
        if (!mGlob.networkSearchText) return true;

        // Search in URL, path, and now also in type
        return (
          req.url.toLowerCase().includes(mGlob.networkSearchText.toLowerCase()) ||
          (req.path &&
            req.path.toLowerCase().includes(mGlob.networkSearchText.toLowerCase())) ||
          (req.type &&
            req.type.toLowerCase().includes(mGlob.networkSearchText.toLowerCase()))
        );
      });

      // Clear previous content
      networkTimeline.innerHTML = "";

      if (filteredRequests.length === 0) {
        networkTimeline.innerHTML =
          '<tr><td colspan="7" class="text-center py-4">No network requests recorded</td></tr>';
        return;
      }

      // Use the first event as the base timestamp for relative time display
      const baseTimestamp =
        mGlob.rrwebEvents.length > 0
          ? mGlob.rrwebEvents[0].timestamp
          : filteredRequests.length > 0
            ? new Date(filteredRequests[0].timestamp).getTime()
            : 0;

      // Create network request items
      filteredRequests.forEach((req) => {
        const row = document.createElement("tr");
        row.className = "hover";

        // Format the size - ensure it's a number
        const size =
          typeof req.size === "number" ? req.size : parseInt(req.size) || 0;
        const formattedSize = formatBytes(size);

        // Format the duration to 2 decimal places
        const duration =
          typeof req.duration === "number"
            ? req.duration
            : parseFloat(req.duration) || 0;
        const formattedDuration = duration.toFixed(2) + " ms";

        // Get full path from URL
        const fullPath = req.path ? req.path : getFullPath(req.url);

        // Get request method
        const method = req.method || req.initiatorType || "other";

        // Format status code with color
        let statusHtml = "N/A";
        console.log("req.statusCode", req.statusCode, req);
        if (req.statusCode) {
          let statusClass = "";
          if (req.statusCode >= 500) statusClass = "text-error font-bold";
          else if (req.statusCode >= 400) statusClass = "text-error";
          else if (req.statusCode >= 300) statusClass = "text-warning";
          else if (req.statusCode >= 200) statusClass = "text-success";

          statusHtml = `<span class="${statusClass}">${req.statusCode}</span>`;
        }

        // Format timestamp relative to base
        let timeDisplay = "-";
        if (req.timestamp) {
          const timestamp = new Date(req.timestamp).getTime();
          timeDisplay = formatTimestamp(timestamp, baseTimestamp);
        }

        // Create row cells
        row.innerHTML = `
                <td class="max-w-xs truncate">${fullPath}</td>
                <td>${method}</td>
                <td>${statusHtml}</td>
                <td>${req.type || "unknown"}</td>
                <td>${formattedSize}</td>
                <td>${formattedDuration}</td>
                <td>${timeDisplay}</td>
            `;

        // Add tooltip with full URL
        row.title = req.url;

        networkTimeline.appendChild(row);
      });
    }

    // Network search functionality
    networkSearchBtn?.addEventListener("click", () => {
      if (networkSearch) {
        mGlob.networkSearchText = networkSearch.value.trim().toLowerCase();
        updateNetworkRequestsView();
      }
    });

    networkSearch?.addEventListener("keyup", (e) => {
      if (e.key === "Enter" && networkSearch) {
        mGlob.networkSearchText = networkSearch.value.trim().toLowerCase();
        updateNetworkRequestsView();
      }
    });

    // Tab switching (update to include network tab and better highlighting)
    timelineViewBtn?.addEventListener("click", () => {
      mGlob.currentView = "timeline";
      updateTabHighlighting(timelineViewBtn);
      timelineView!.classList.remove("hidden");
      rawJsonView!.classList.add("hidden");
      consoleLogsView!.classList.add("hidden");
      networkRequestsView!.classList.add("hidden");
    });

    rawViewBtn?.addEventListener("click", () => {
      mGlob.currentView = "raw";
      updateTabHighlighting(rawViewBtn);
      rawJsonView!.classList.remove("hidden");
      timelineView!.classList.add("hidden");
      consoleLogsView!.classList.add("hidden");
      networkRequestsView!.classList.add("hidden");
    });

    consoleViewBtn?.addEventListener("click", () => {
      mGlob.currentView = "console";
      updateTabHighlighting(consoleViewBtn);
      consoleLogsView!.classList.remove("hidden");
      timelineView!.classList.add("hidden");
      rawJsonView!.classList.add("hidden");
      networkRequestsView!.classList.add("hidden");
      updateConsoleLogsView();
    });

    networkViewBtn?.addEventListener("click", () => {
      mGlob.currentView = "network";
      updateTabHighlighting(networkViewBtn);
      networkRequestsView!.classList.remove("hidden");
      timelineView!.classList.add("hidden");
      rawJsonView!.classList.add("hidden");
      consoleLogsView!.classList.add("hidden");
      updateNetworkRequestsView();
    });

    // Filter by log level - enhanced to update the display text
    document.querySelectorAll(".log-level-filter").forEach((levelBtn) => {
      levelBtn.addEventListener("click", (e) => {
        e.preventDefault();

        // Get the selected level
        const target = e.currentTarget as HTMLElement;
        const level = target.getAttribute("data-level") || "any";

        // Update the filter
        mGlob.currentLogLevel = level;

        // Update active class
        document.querySelectorAll(".log-level-filter").forEach((btn) => {
          btn.classList.remove("active");
        });
        target.classList.add("active");

        // Update the dropdown label
        const levelDisplay = document.getElementById("log-level-display");
        if (levelDisplay) {
          const displayText = level === "any" ? "Any" : formatLogLevel(level);
          levelDisplay.textContent = `Log Level: ${displayText}`;
        }

        // Update the view
        updateConsoleLogsView();
      });
    });

    // Search functionality
    consoleSearch?.addEventListener("input", (e) => {
      mGlob.consoleSearchText = (e.target as HTMLInputElement).value.toLowerCase();
      updateConsoleLogsView();
    });

    consoleSearchBtn?.addEventListener("click", () => {
      updateConsoleLogsView();
    });

    // Jump to current timestamp
    jumpToCurrentBtn?.addEventListener("click", () => {
      if (mGlob.playerInstance && typeof mGlob.playerInstance.goto === "function") {
        // Get the current player position
        const currentTime = mGlob.playerInstance.getCurrentTime
          ? mGlob.playerInstance.getCurrentTime()
          : mGlob.playerInstance.replayer
            ? mGlob.playerInstance.replayer.getCurrentTime()
            : 0;

        mGlob.playerInstance.goto(currentTime);
      }
    });

    // Copy button handler
    jsonCopyBtn.addEventListener("click", () => {
      try {
        let textToCopy = "";

        if (mGlob.currentView === "raw") {
          textToCopy = jsonContent!.textContent || "";
        } else if (mGlob.selectedEventIndex >= 0) {
          // Copy only the selected event JSON if in timeline view
          textToCopy = JSON.stringify(mGlob.rrwebEvents[mGlob.selectedEventIndex], null, 2);
        } else if (mGlob.rrwebEvents.length > 0) {
          // If no event selected but events exist, copy all
          textToCopy = JSON.stringify(mGlob.rrwebEvents, null, 2);
        }

        navigator.clipboard.writeText(textToCopy);
        updateStatus("JSON copied to clipboard.");
      } catch (error) {
        console.error("Error copying to clipboard:", error);
        updateStatus("Error copying to clipboard.");
      }
    });

    function updateStatus(text: string) {
      if (statusEl) statusEl.textContent = `Status: ${text}`;
    }
    initRecorder();
    // let isRecording = false;
    // // Prevent Sentry from capturing expected errors
    // setupErrorPrevention();

    // // Set up message listener from iframe
    // window.addEventListener("message", (event) => {
    //   // Security check to validate message source (should be more specific in production)
    //   if (event.source !== recordFrame?.contentWindow) {
    //     console.warn("Parent: Received message from unknown source, ignoring.");
    //     return;
    //   }

    //   // Process different message types
    //   switch (event.data?.type) {
    //     case "iframeReady":
    //       console.log("Parent: Received iframe ready notification.");
    //       if (startBtn) startBtn.disabled = false;
    //       if (statusEl) statusEl.textContent = "Status: Ready";
    //       break;

    //     case "rrwebEvent":
    //       if (isRecording && event.data.event) {
    //         mGlob.rrwebEvents.push(event.data.event);
    //         // If this is a console log event, extract it
    //         if (
    //           event.data.event.type === EventType.Plugin &&
    //           event.data.event.data.plugin === "rrweb/console@1"
    //         ) {
    //           // Extract the console log data and add timestamp
    //           const logData = { ...event.data.event.data.payload };
    //           logData.timestamp = event.data.event.timestamp;
    //           mGlob.consoleLogs.push(logData);
    //         }
    //       }
    //       break;

    //     case "statusUpdate":
    //       console.log(`Parent: Received status update: ${event.data.text}`);
    //       if (statusEl) statusEl.textContent = `Status: ${event.data.text}`;
    //       break;

    //     case "consoleLog":
    //       if (isRecording && event.data) {
    //         mGlob.consoleLogs.push(event.data);
    //       }
    //       break;

    //     case "networkRequest":
    //       if (isRecording && event.data && event.data.request) {
    //         mGlob.networkRequests.push(event.data.request);
    //       }
    //       break;

    //     case "allNetworkRequests":
    //       if (event.data && event.data.requests) {
    //         // Replace any individually received requests with the complete set
    //         mGlob.networkRequests = event.data.requests;
    //       }
    //       break;

    //     default:
    //       console.log(
    //         "Parent: Received unknown message type from iframe:",
    //         event.data
    //       );
    //   }
    // });

    // // --- Parent Button Event Listeners ---

    // startBtn.addEventListener("click", () => {
    //   if (isRecording) {
    //     console.warn("Parent: Start clicked but already recording.");
    //     return;
    //   }

    //   const iframeWin =
    //     recordFrame.contentWindow as IframeWindowWithRecorder | null;

    //   if (iframeWin && typeof iframeWin.startRecordingInIframe === "function") {
    //     isRecording = true;
    //     mGlob.rrwebEvents = [];
    //     mGlob.consoleLogs = []; // Clear console logs when starting a new recording
    //     updateStatus("Recording... (in iframe)");
    //     startBtn.disabled = true;
    //     stopBtn.disabled = false;

    //     // Clear previous replay
    //     if (mGlob.playerInstance) {
    //       // For rrweb-player we need to remove it from DOM
    //       if (replayContainer) replayContainer.innerHTML = "";
    //       mGlob.playerInstance = null;
    //     }

    //     // Reset timeline view
    //     if (eventTimeline) {
    //       eventTimeline.innerHTML =
    //         '<div class="p-4 text-center text-base-content/60">Recording in progress...</div>';
    //     }

    //     // Call the function defined INSIDE the iframe
    //     iframeWin.startRecordingInIframe();
    //   } else {
    //     updateStatus(
    //       "Error: Cannot call start function in iframe. Is it loaded?"
    //     );
    //     console.error(
    //       "Parent: Iframe window or startRecordingInIframe function not available."
    //     );
    //     // Don't disable start button here, let user retry
    //   }
    // });

    // stopBtn.addEventListener("click", () => {
    //   if (!isRecording) return;

    //   const iframeWin =
    //     recordFrame.contentWindow as IframeWindowWithRecorder | null;

    //   // Call stop function inside iframe
    //   if (iframeWin && typeof iframeWin.stopRecordingInIframe === "function") {
    //     iframeWin.stopRecordingInIframe();
    //   } else {
    //     console.warn(
    //       "Parent: Could not call stop function in iframe. Events might be incomplete."
    //     );
    //   }

    //   isRecording = false;
    //   updateStatus("Recording stopped. Preparing replay...");
    //   stopBtn.disabled = true;

    //   // Format the JSON for raw view
    //   const formattedJson = JSON.stringify(mGlob.rrwebEvents, null, 2);
    //   jsonContent!.textContent = formattedJson;

    //   // Generate the timeline view
    //   generateTimelineView(mGlob.rrwebEvents);

    //   // Update the console logs view
    //   updateConsoleLogsView();

    //   // Update the network requests view
    //   updateNetworkRequestsView();

    //   // Set view to timeline
    //   mGlob.currentView = "timeline";
    //   timelineViewBtn!.classList.add("tab-active");
    //   rawViewBtn!.classList.remove("tab-active");
    //   consoleViewBtn!.classList.remove("tab-active");
    //   timelineView!.classList.remove("hidden");
    //   rawJsonView!.classList.add("hidden");
    //   consoleLogsView!.classList.add("hidden");
    //   networkRequestsView!.classList.add("hidden");

    //   initPlayer(mGlob.rrwebEvents, replayContainer);
    // });
  });
</script>

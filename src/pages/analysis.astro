---
import Layout from '../components/Layout.astro';
import { getSession } from "auth-astro/server";
import { sqlQueries } from '../lib/sql_query_locale'; // Adjust import path

const session = await getSession(Astro.request);

if (!session) {
  return Astro.redirect('/login');
}

const pageTitle = "ClickstreamDB - Database Overview";
const API_URL = `${Astro.url.origin}/api/query_mysql`;

let userCount = 0;
let webstateCount = 0;
let replayCount = 0;
let eventCount = 0;
let clickEventsPerSecondData: { second: string; count: number }[] = []; // Renamed and updated type
let fetchError: string | null = null;

// Helper function to fetch counts
async function fetchCount(query: string): Promise<number> {
    const response = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query })
    });
    if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API Error (${response.status}): ${errorData.error?.message || errorData.error || 'Failed to fetch count'}`);
    }
    const data = await response.json();
    if (data.success && Array.isArray(data.rows) && data.rows.length > 0) {
        return parseInt(data.rows[0].count) || 0;
    } else {
        throw new Error(data.error?.message || data.error || 'Invalid data format for count query');
    }
}

// Helper function to fetch time series data (updated for second granularity)
async function fetchTimeSeriesPerSecond(query: string): Promise<{ second: string; count: number }[]> {
    const response = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query })
    });
    if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API Error (${response.status}): ${errorData.error?.message || errorData.error || 'Failed to fetch time series data'}`);
    }
    const data = await response.json();
    if (data.success && Array.isArray(data.rows)) {
        // Ensure count is a number and second exists
        return data.rows.map((row: { second: any; count: any }) => ({ 
            second: String(row.second), // Ensure second is string
            count: parseInt(row.count) || 0 
        })).filter(row => row.second); // Filter out rows with no second
    } else {
        throw new Error(data.error?.message || data.error || 'Invalid data format for time series query');
    }
}

try {
    // Fetch all data in parallel, using the new query for time series
    const results = await Promise.allSettled([
        fetchCount(sqlQueries.countUsers),
        fetchCount(sqlQueries.countWebstates),
        fetchCount(sqlQueries.countReplays),
        fetchCount(sqlQueries.countEvents),
        fetchTimeSeriesPerSecond(sqlQueries.clickEventsPerSecond) // Use the per-second query
    ]);

    // Process results safely
    if (results[0].status === 'fulfilled') userCount = results[0].value;
    if (results[1].status === 'fulfilled') webstateCount = results[1].value;
    if (results[2].status === 'fulfilled') replayCount = results[2].value;
    if (results[3].status === 'fulfilled') eventCount = results[3].value;
    if (results[4].status === 'fulfilled') {
        clickEventsPerSecondData = results[4].value; // Assign to the renamed variable
        console.log("[Astro Frontmatter] Fetched clickEventsPerSecondData:", clickEventsPerSecondData);
    } else {
        console.error("[Astro Frontmatter] Failed to fetch clickEventsPerSecondData:", results[4].reason);
    }

    // Collect errors from basic counts if any
    const countErrors = results.slice(0, 4).filter(r => r.status === 'rejected') as PromiseRejectedResult[];
    if (countErrors.length > 0) {
        fetchError = countErrors.map(e => e.reason?.message || 'Unknown error').join('; ');
        console.error("Errors fetching database counts:", countErrors.map(e => e.reason));
    }
    // Add time series error if it occurred
    if (results[4].status === 'rejected') {
         const timeSeriesError = results[4].reason?.message || 'Error fetching click time series data';
         fetchError = fetchError ? `${fetchError}; ${timeSeriesError}` : timeSeriesError;
    }

} catch (error: any) {
    console.error("Unexpected error fetching database stats:", error);
    fetchError = error.message || "Could not load database statistics.";
}

---

<Layout title={pageTitle}>
  <h1 class="text-2xl font-bold mb-6">Database Overview</h1>

  { fetchError && <div class="alert alert-warning shadow-lg mb-4"><span>Warning: {fetchError}</span></div> }

  <div class="stats shadow w-full mb-8">
    <div class="stat">
      <div class="stat-title">Users</div>
      <div class="stat-value">{userCount.toLocaleString()}</div>
    </div>
        <div class="stat">
      <div class="stat-title">Webstates</div>
      <div class="stat-value">{webstateCount.toLocaleString()}</div>
        </div>
        <div class="stat">
      <div class="stat-title">Replays</div>
      <div class="stat-value">{replayCount.toLocaleString()}</div>
        </div>
        <div class="stat">
      <div class="stat-title">Total Events</div>
      <div class="stat-value">{eventCount.toLocaleString()}</div>
    </div>
  </div>

  <h2 class="text-xl font-semibold mb-4">Click Events Recorded Per Second</h2>
  <div class="bg-base-200 rounded-box p-4">
    {clickEventsPerSecondData.length > 0 ? (
      <canvas id="eventsOverTimeChart"></canvas>
    ) : (
      <p class="text-base-content/50">No click event data available to display chart, or an error occurred fetching data.</p>
    )}
  </div>

  <div class="mt-8 p-4 bg-base-200 rounded-box">
    <h2 class="text-xl font-semibold mb-2">Notes</h2>
    <p>This page shows basic counts and a summary of event recording activity.</p>
  </div>

</Layout>

<!-- Script to safely pass data to the client -->
<script define:vars={{ clickEventsPerSecondData }} is:inline>
    window.chartData = JSON.parse(JSON.stringify(clickEventsPerSecondData)); 
</script>

<script>
import { Chart, registerables } from 'chart.js/auto'; 

  // Extend the Window interface
  declare global {
      interface Window {
          chartData: { second: string; count: number }[] | undefined; // Updated type 
      }
  }

  const canvas = document.getElementById('eventsOverTimeChart');
  console.log("[Debug Chart] Canvas element:", canvas);
  
  const clientClickEventsPerSecondData = window.chartData; 
  console.log("[Debug Chart] clickEventsPerSecondData read from window:", clientClickEventsPerSecondData);

  if (canvas instanceof HTMLCanvasElement && clientClickEventsPerSecondData && clientClickEventsPerSecondData.length > 0) {
    console.log("[Debug Chart] Canvas found and click data exists. Attempting to create chart.");
    try {
        Chart.register(...registerables);

        const smallestTime = Date.parse(clientClickEventsPerSecondData[0].second);
        const biggestTime = Date.parse(clientClickEventsPerSecondData[clientClickEventsPerSecondData.length-1].second);
        let timeDict = new Map<number, number | null>();


        for (let i = smallestTime; i <= biggestTime; i += 1000){
          timeDict.set(i,0);
        }

        for(var i of clientClickEventsPerSecondData ){
          timeDict.set(Date.parse(i.second),i.count);
        }

        // Use the 'second' string directly as the label
        const labels = Array.from(timeDict.keys()); 
        const dataCounts = Array.from(timeDict.entries());
        console.log("[Debug Chart] Processed labels (seconds):", labels);
        console.log("[Debug Chart] Processed dataCounts:", dataCounts);

        new Chart(canvas, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: 'Click Events Recorded per Second',
              data: dataCounts,
              borderColor: 'lightblue', // Higher contrast color
              backgroundColor: 'rgba(173, 216, 230, 0.2)', // Lighter background
              fill: true,
              spanGaps: true,
              tension: 0.1 
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false, 
            scales: {
              y: {
                beginAtZero: true,
                title: {
                    display: true,
                    text: 'Number of Click Events',
                    color: '#E5E7EB' // Light color for title
                },
                ticks: {
                    color: '#E5E7EB' // Light color for ticks
                }
              },
              x: {
                 title: {
                    display: true,
                    text: 'Time (Second)', // Updated axis title
                    color: '#E5E7EB' // Light color for title
                 },
                 ticks: {
                     color: '#E5E7EB', // Light color for ticks
                     // Optional: Auto-skip ticks if labels become too dense
                     autoSkip: true,
                     maxTicksLimit: 20 // Adjust as needed
                 }
              }
            },
            plugins: {
                legend: {
                    display: false 
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                }
            }
          }
        });
        console.log("[Debug Chart] Chart object created successfully.");
    } catch (error) {
        console.error("[Debug Chart] Error creating chart:", error);
    }
                } else {
      console.log("[Debug Chart] Condition not met: Canvas found?", canvas instanceof HTMLCanvasElement, "Data exists?", !!clientClickEventsPerSecondData, "Data length > 0?", clientClickEventsPerSecondData ? clientClickEventsPerSecondData.length > 0 : false);
    }

  </script>

---
import Layout from '../components/Layout.astro';
import { getSession } from "auth-astro/server";

const session = await getSession(Astro.request);

if (!session) {
  return Astro.redirect('/login');
}

const pageTitle = "ClickstreamDB - Page Click Summary";
const API_URL = `${Astro.url.origin}/api/query_mysql`; 

// Fetch distinct html_hash values from the new summary table
let availablePages: { html_hash: string }[] = [];
let initialError: string | null = null;
try {
    // Query the new page_summary table
    const query = "SELECT html_hash FROM page_summary ORDER BY html_hash;";
    const response = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query })
    });
    if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API Error (${response.status}): ${errorData.error?.message || errorData.error || 'Failed to fetch pages'}`);
    }
    const data = await response.json();
    if (data.success && Array.isArray(data.rows)) {
        availablePages = data.rows;
    } else {
        throw new Error(data.error?.message || data.error || 'Invalid data format from API');
    }
} catch (error: any) {
    console.error("Error fetching available pages:", error);
    initialError = error.message || "Could not load available pages for analysis.";
}

---

<Layout title={pageTitle}>
  <h1 class="text-2xl font-bold mb-6">Page Click Summary</h1>

  { initialError && <div class="alert alert-error shadow-lg mb-4"><span>Error loading page list: {initialError}</span></div> }

  <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
    <!-- Controls -->
    <div class="md:col-span-1 space-y-4">
      <div class="form-control w-full">
        <label class="label" for="page-select">
          <span class="label-text">Select Page (HTML Hash)</span>
        </label>
        <select id="page-select" class="select select-bordered w-full" disabled={availablePages.length === 0}>
          <option disabled selected={availablePages.length === 0}>Select a page</option>
          {availablePages.map(page => (
            <option value={page.html_hash}>{page.html_hash.substring(0, 12)}...</option> // Shorten hash for display
          ))}
        </select>
        { availablePages.length === 0 && !initialError && 
          <label class="label">
            <span class="label-text-alt">No aggregated data found. Run aggregation first.</span>
          </label> 
        }
      </div>
      
      <!-- Aggregation Button and Status -->
      <div class="form-control w-full mt-4 pt-4 border-t border-base-300">
        <label class="label">
            <span class="label-text">Manual Aggregation</span>
        </label>
        <button id="run-aggregation-btn" class="btn btn-secondary w-full">Run Data Aggregation</button>
        <div id="aggregation-status" class="text-sm mt-2 min-h-[5em] p-2 bg-base-200 rounded overflow-auto"> 
          Click the button to aggregate click data for analysis.
        </div>
      </div>
      
    </div>

    <!-- Data Display Area -->
    <div class="md:col-span-3">
      <div id="data-display-area" 
           class="bg-base-200 rounded-box border border-base-300 p-4 min-h-[150px]">
        <span id="data-placeholder" class="text-base-content/50">Select a page to view total clicks.</span>
        <!-- Table will be added here by JS -->
      </div>
    </div>
  </div>

  <script define:vars={{ API_URL, initialError }}>
    // No heatmap.js needed anymore
    
    const pageSelect = document.getElementById('page-select');
    const dataDisplayArea = document.getElementById('data-display-area');
    const dataPlaceholder = document.getElementById('data-placeholder');
    const runAggregationBtn = document.getElementById('run-aggregation-btn');
    const aggregationStatus = document.getElementById('aggregation-status');

    let currentHtmlHash = null;
    
    function clearDataDisplay() {
        if (!dataDisplayArea || !dataPlaceholder) return;
        dataDisplayArea.innerHTML = ''; // Clear previous content/table
        dataDisplayArea.appendChild(dataPlaceholder); // Add placeholder back
        dataPlaceholder.textContent = 'Loading data...';
        dataPlaceholder.style.display = 'block'; // Ensure visible
    }

    async function fetchAnalysisData(htmlHash) {
        console.log(`[Debug] fetchAnalysisData called for hash: ${htmlHash}`); // Debug log
        clearDataDisplay();

        if (!dataPlaceholder) return;

        const query = `SELECT html_hash, total_clicks, last_updated FROM page_summary WHERE html_hash = '${htmlHash}';`;
        console.log(`[Debug] Executing query: ${query}`); // Debug log

        try {
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query })
            });
            
            console.log(`[Debug] API Response Status: ${response.status}`); // Debug log
            const responseText = await response.text(); // Get raw text first
            console.log(`[Debug] API Response Text: ${responseText}`); // Debug log
            
            if (!response.ok) {
                let errorData;
                try { errorData = JSON.parse(responseText); } catch (e) { errorData = { error: responseText }; }
                throw new Error(`API Error (${response.status}): ${errorData.error?.message || errorData.error || 'Failed to fetch summary data'}`);
            }

            const result = JSON.parse(responseText); // Parse after checking ok status
            console.log(`[Debug] Parsed API Result:`, result); // Debug log

            if (result.success && Array.isArray(result.rows)) {
                if (result.rows.length === 0) {
                   console.log(`[Debug] No data found for hash ${htmlHash}. Displaying placeholder.`); // Debug log
                   dataPlaceholder.textContent = `No summary data found for this page. Run aggregation if needed.`;
                   dataPlaceholder.style.display = 'block'; 
                } else {
                   console.log(`[Debug] Data found for hash ${htmlHash}. Calling renderData.`); // Debug log
                   dataPlaceholder.style.display = 'none'; // Hide placeholder
                   renderData(result.rows[0]); // Render the first (only) row
                }
            } else {
                throw new Error(result.error?.message || result.error || 'Invalid data format from API');
            }
        } catch (error) { 
            console.error("[Debug] Error in fetchAnalysisData:", error); // Debug log
            dataPlaceholder.style.display = 'block';
            dataPlaceholder.textContent = `Error loading data: ${error.message}`;
        }
    }

    function renderData(data) {
       if (!dataDisplayArea) return;

       dataDisplayArea.innerHTML = ''; // Clear placeholder

       const table = document.createElement('table');
       table.className = 'table w-full';
       
       const thead = table.createTHead();
       thead.innerHTML = `<tr><th>Metric</th><th>Value</th></tr>`;
       
       const tbody = table.createTBody();
       tbody.innerHTML = `
         <tr>
           <td>Page Hash</td>
           <td class="font-mono text-xs">${data.html_hash}</td>
         </tr>
         <tr>
           <td>Total Clicks Recorded</td>
           <td class="font-bold text-lg">${(parseInt(data.total_clicks) || 0).toLocaleString()}</td>
         </tr>
         <tr>
           <td>Last Aggregated</td>
           <td>${new Date(data.last_updated).toLocaleString()}</td>
         </tr>
       `;

       dataDisplayArea.appendChild(table);
    }

    // --- Aggregation Logic (Mostly unchanged, calls the simplified procedure) ---
    function updateAggregationStatus(message, isError = false) {
        console.log(`[Debug] updateAggregationStatus called with message: ${message}`); // Log entry
        if (aggregationStatus) {
            const line = document.createElement('div');
            line.textContent = message;
            if (isError) {
                line.classList.add('text-error');
            }
            // Prepend new messages and limit log lines if needed
            aggregationStatus.insertBefore(line, aggregationStatus.firstChild);
            // Keep only last N lines (e.g., 50)
            // while (aggregationStatus.children.length > 50) { 
            //    aggregationStatus.removeChild(aggregationStatus.lastChild); 
            // }
        } else {
            console.error("[Debug] aggregationStatus element is null inside updateAggregationStatus!"); // Log if null
        }
    }

    async function runAggregation() {
        console.log("runAggregation function called");
        
        console.log("[Debug] Checking button and status elements...");
        if (!runAggregationBtn || !aggregationStatus) {
             console.error("[Debug] runAggregationBtn or aggregationStatus is null! Aborting.");
             return;
        } 
        console.log("[Debug] Elements check passed.");

        console.log("[Debug] Setting button disabled...");
        runAggregationBtn.disabled = true;
        console.log("[Debug] Adding loading class...");
        runAggregationBtn.classList.add('loading');
        console.log("[Debug] Clearing aggregation status HTML...");
        aggregationStatus.innerHTML = ''; // Clear previous status
        console.log("[Debug] Calling updateAggregationStatus('Starting aggregation...')...");
        updateAggregationStatus('Starting aggregation...');
        console.log("[Debug] Returned from updateAggregationStatus. Proceeding to try block...");

        let replays = [];
        try {
            updateAggregationStatus('Fetching replays...');
            console.log("[Debug] Preparing to fetch replays..."); 
            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query: 'SELECT replay_id, html_hash FROM replay;' })
            });
            const result = await response.json();
            if (!response.ok || !result.success) {
                throw new Error(result.error?.message || result.error || 'Failed to fetch replays');
            }
            replays = result.rows;
            updateAggregationStatus(`Found ${replays.length} replays to process.`);
        } catch (error) {
            updateAggregationStatus(`Error fetching replays: ${error.message}`, true);
            console.error("[Debug] Error occurred while fetching replays:", error); 
            runAggregationBtn.disabled = false;
            runAggregationBtn.classList.remove('loading');
            return;
        }

        let successCount = 0;
        let errorCount = 0;

        for (const replay of replays) {
            const { replay_id, html_hash } = replay;
            if (!replay_id || !html_hash) {
                updateAggregationStatus(`Skipping invalid replay data: ${JSON.stringify(replay)}`, true);
                errorCount++;
                continue;
            }
            // Basic escaping - Prefer parameterized queries if API is adapted
            const escapedReplayId = replay_id.replace(/\'/g, "''");
            const escapedHtmlHash = html_hash.replace(/\'/g, "''");
            // Calls the *same* procedure name, which now has simpler logic
            const callQuery = `CALL update_analysis_summaries('${escapedReplayId}', '${escapedHtmlHash}');`;
            
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query: callQuery })
                });
                const result = await response.json();
                if (!response.ok || !result.success) {
                    const errorMsg = result.error?.message || JSON.stringify(result.error) || 'Unknown error executing procedure';
                    updateAggregationStatus(`Error for replay ${replay_id.substring(0,8)}...: ${errorMsg}`, true);
                    errorCount++;
                } else {
                    successCount++;
                    // Update status less frequently on success to avoid flooding
                    if (successCount % 10 === 0 || successCount === replays.length) {
                         updateAggregationStatus(`${successCount} / ${replays.length} processed...`);
                    }
                }
            } catch (error) {
                updateAggregationStatus(`Fetch error for replay ${replay_id.substring(0,8)}...: ${error.message}`, true);
                errorCount++;
            }
             // await new Promise(resolve => setTimeout(resolve, 10)); // Optional small delay
        }

        updateAggregationStatus(`Aggregation finished. Success: ${successCount}, Errors: ${errorCount}`);
        runAggregationBtn.disabled = false;
        runAggregationBtn.classList.remove('loading');
        updateAggregationStatus('Consider refreshing the page or re-selecting a page to see updated data.');
    }

    // --- Event Listeners ---
    if (pageSelect) {
        pageSelect.addEventListener('change', () => {
            // Get the full hash from the option's value attribute
            const selectedOption = pageSelect.options[pageSelect.selectedIndex];
            currentHtmlHash = selectedOption.value; 
            
            if (currentHtmlHash && pageSelect.selectedIndex > 0) { 
                fetchAnalysisData(currentHtmlHash);
            } else {
                currentHtmlHash = null; 
                clearDataDisplay();
                if (dataPlaceholder) dataPlaceholder.textContent = 'Select a page to view total clicks.';
            }
        });
    } else {
        console.error("Page select element not found");
    }

    // Remove viewTabs listener
    // if (viewTabs) { ... }

    if (runAggregationBtn) {
        runAggregationBtn.addEventListener('click', runAggregation);
    } else {
        console.error("Run Aggregation button not found");
    }

    // Initial state setup
    if (!pageSelect?.disabled && dataPlaceholder) {
        dataPlaceholder.textContent = 'Select a page to view total clicks.';
    } else if (pageSelect?.disabled && dataPlaceholder) {
        dataPlaceholder.textContent = initialError || 'No aggregated data found. Run aggregation first.';
    }

  </script>
</Layout> 

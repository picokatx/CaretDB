<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recordable DOM (Self-Contained)</title>
    <!-- Add DaisyUI and Tailwind CSS -->
    <style>
        body { 
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; 
            padding: 20px; 
            background-color: #e0e0e0; 
            color: #111;
            line-height: 1.6;
        }
        button { padding: 10px 15px; margin: 10px 0; cursor: pointer; border-radius: 5px; border: 1px solid #555; background-color: #ccc; }
        button:hover { background-color: #bbb; }
        input[type="text"], textarea, select { padding: 10px; margin: 10px 0; width: 90%; border: 1px solid #777; border-radius: 5px; }
        #message { margin-top: 15px; padding: 10px; background-color: #f8f8f8; border: 1px solid #ccc; border-radius: 5px; min-height: 20px; }
        h1 { color: #333; }
        .card {
            background-color: #f8f8f8;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
        }
        h2 {
            margin-top: 0;
            color: #444;
            font-size: 1.2em;
        }
        .request-controls, .request-examples {
            margin-bottom: 10px;
        }
        .example-btn {
            padding: 5px 10px;
            margin-right: 5px;
            font-size: 0.9em;
        }
    </style>
    <!-- Load rrweb library - use the standard browser build -->
    <script src="https://cdn.jsdelivr.net/npm/rrweb@latest/dist/rrweb.min.js"></script>
</head>
<body>
    <h1>Interact with this DOM</h1>
    <p>Your actions here will be recorded when instructed by the parent page.</p>
    
    <div class="card">
        <h2>Console Logs Testing</h2>
    <label for="text-input">Text Input:</label><br>
    <input type="text" id="text-input" placeholder="Type something..."><br>

        <label for="click-button">Generate Console Logs:</label><br>
        <button id="click-button">Click to Log in Console</button><br>
    
    <label for="text-area">Text Area:</label><br>
    <textarea id="text-area" rows="3" placeholder="Enter multiple lines..."></textarea>
    </div>

    <div class="card">
        <h2>Network Requests Testing</h2>
        <div class="request-controls">
            <label for="url-input">Request URL:</label>
            <input type="text" id="url-input" placeholder="https://example.com/api" value="https://jsonplaceholder.typicode.com/todos/1">
            
            <label for="method-select">Method:</label>
            <select id="method-select">
                <option value="GET">GET</option>
                <option value="POST">POST</option>
            </select>
            
            <button id="fetch-button">Make Request</button>
        </div>
        
        <div class="request-examples">
            <p>Quick Examples:</p>
            <button class="example-btn" data-url="https://jsonplaceholder.typicode.com/todos/1">Fetch Todo</button>
            <button class="example-btn" data-url="https://jsonplaceholder.typicode.com/users">Fetch Users</button>
            <button class="example-btn" data-url="https://jsonplaceholder.typicode.com/photos">Fetch Photos</button>
        </div>
        
        <div class="request-test-methods mt-4">
            <p>Test Different Request Methods:</p>
            <button id="test-xhr-btn" class="example-btn">Test XHR</button>
            <button id="test-fetch-btn" class="example-btn">Test Fetch</button>
            <button id="test-image-btn" class="example-btn">Test Image Load</button>
            <button id="test-all-btn" class="example-btn">Test All Methods</button>
        </div>
    </div>

    <div id="message">Status updates appear here...</div>

    <script>
        const btn = document.getElementById('click-button');
        const input = document.getElementById('text-input');
        const textarea = document.getElementById('text-area');
        const msgDiv = document.getElementById('message');
        const urlInput = document.getElementById('url-input');
        const methodSelect = document.getElementById('method-select');
        const fetchButton = document.getElementById('fetch-button');
        const exampleButtons = document.querySelectorAll('.example-btn');

        let iframeStopFn = undefined; // Variable to hold the stop recording function
        // IMPORTANT: Determine the parent origin reliably in production!
        // Using '*' is insecure. For dev, assuming localhost is okay.
        const parentOrigin = '*'; // Replace with window.location.ancestorOrigins[0] or a known origin

        // Override console methods to capture logs
        const originalConsole = {
            log: console.log,
            warn: console.warn,
            error: console.error,
            info: console.info,
            debug: console.debug
        };

        // Track if recording is active
        let isRecording = false;

        // Function to override console methods
        function overrideConsole() {
            console.log = function() {
                originalConsole.log.apply(console, arguments);
                if (isRecording) {
                    sendConsoleLog('log', Array.from(arguments));
                }
            };
            
            console.warn = function() {
                originalConsole.warn.apply(console, arguments);
                if (isRecording) {
                    sendConsoleLog('warn', Array.from(arguments));
                }
            };
            
            console.error = function() {
                originalConsole.error.apply(console, arguments);
                if (isRecording) {
                    sendConsoleLog('error', Array.from(arguments));
                }
            };
            
            console.info = function() {
                originalConsole.info.apply(console, arguments);
                if (isRecording) {
                    sendConsoleLog('info', Array.from(arguments));
                }
            };
            
            console.debug = function() {
                originalConsole.debug.apply(console, arguments);
                if (isRecording) {
                    sendConsoleLog('debug', Array.from(arguments));
                }
            };
        }

        // Function to restore original console methods
        function restoreConsole() {
            console.log = originalConsole.log;
            console.warn = originalConsole.warn;
            console.error = originalConsole.error;
            console.info = originalConsole.info;
            console.debug = originalConsole.debug;
        }

        // Function to send console logs to parent
        function sendConsoleLog(level, args) {
            try {
                // Serialize arguments to handle complex objects
                const serializedArgs = args.map(arg => {
                    if (typeof arg === 'object') {
                        try {
                            return JSON.stringify(arg);
                        } catch (e) {
                            return String(arg);
                        }
                    }
                    return arg;
                });
                
                window.parent.postMessage({
                    type: 'consoleLog',
                    level: level,
                    args: serializedArgs,
                    timestamp: Date.now()
                }, parentOrigin);
            } catch (e) {
                originalConsole.error('Error sending console log to parent:', e);
            }
        }

        // Basic interaction feedback
        btn.addEventListener('click', () => {
            msgDiv.textContent = 'Console logs generated at ' + new Date().toLocaleTimeString();
            console.log('Button clicked! This generates a basic console.log entry');
            console.info('Button info:', { element: 'click-button', time: new Date().toISOString() });
            console.warn('This is a warning log from the button click');
            if (input.value) {
                console.log('Input contains text:', input.value);
            } else {
                console.error('No text in the input field!');
            }
        });
        input.addEventListener('input', (e) => {
            msgDiv.textContent = `Input value: ${e.target.value}`;
            console.log('Input changed:', e.target.value);
        });
        textarea.addEventListener('input', (e) => {
            msgDiv.textContent = `Textarea content changed. Length: ${e.target.value.length}`;
            console.log('Textarea updated, new length:', e.target.value.length);
            if (e.target.value.length > 50) {
                console.warn('Textarea content is getting long');
            }
        });

        // Prevent errors from propagating to Sentry
        window.addEventListener('error', (event) => {
            if (event.message && (
                event.message.includes('SecurityError') || 
                event.message.includes('cross-origin') || 
                event.message.includes('stylesheet')
            )) {
                event.stopImmediatePropagation();
                event.preventDefault();
                console.warn('[iframe] Prevented error from propagating:', event.message);
                return true;
            }
            return false;
        }, true);

        // --- rrweb Recording Logic --- 

        // Network request recording
        let networkRequests = [];
        
        // Track network requests manually (for more accurate size)
        const manuallyTrackedRequests = {};

        // Store original network method references
        let originalXHROpen = null;
        let originalXHRSend = null;
        let originalXHRSetRequestHeader = null;
        let originalFetch = null;

        // Simple function to detect content type from URL or headers
        function detectContentType(url, headers, initiatorType) {
            // First, use initiatorType if available - most accurate source
            if (initiatorType) {
                switch (initiatorType) {
                    case 'img':         return 'image';
                    case 'css':         return 'stylesheet';
                    case 'script':      return 'script';
                    case 'fetch':       return 'fetch';
                    case 'xmlhttprequest': return 'xhr';
                    case 'beacon':      return 'beacon';
                    case 'audio':       return 'audio';
                    case 'video':       return 'video';
                    case 'navigation':  return 'document';
                    case 'iframe':      return 'document';
                    case 'frame':       return 'document';
                    case 'link':        
                        // <link> can be used for stylesheets, prefetch, etc.
                        if (url.endsWith('.css')) return 'stylesheet';
                        return 'link';
                    // Other possible values: object, embed, track, ping, early-hint, etc.
                }
            }
            
            // Then try to get from content-type header if available
            if (headers) {
                const contentType = headers['content-type'] || headers['Content-Type'];
                if (contentType) {
                    // Strip charset and other parameters
                    const mimeType = contentType.split(';')[0].trim();
                    
                    // Map common MIME types to simplified categories
                    if (mimeType.startsWith('image/')) return 'image';
                    if (mimeType.startsWith('text/css')) return 'stylesheet';
                    if (mimeType.startsWith('text/html')) return 'document';
                    if (mimeType.includes('javascript')) return 'script';
                    if (mimeType === 'application/json') return 'json';
                    if (mimeType.startsWith('font/') || mimeType.includes('font')) return 'font';
                    if (mimeType.startsWith('audio/')) return 'audio';
                    if (mimeType.startsWith('video/')) return 'video';
                    
                    // Return the raw MIME type if it doesn't fit our categories
                    return mimeType;
                }
            }
            
            // Lastly, try to infer from URL
            try {
                // Check for image extensions
                if (/\.(jpg|jpeg|png|gif|webp|svg|ico)($|\?)/.test(url.toLowerCase())) {
                    return 'image';
                }
                
                // Check for script/css
                if (/\.js($|\?)/.test(url.toLowerCase())) return 'script';
                if (/\.css($|\?)/.test(url.toLowerCase())) return 'stylesheet';
                
                // Check for document types
                if (/\.html?($|\?)/.test(url.toLowerCase())) return 'document';
                
                // Check for data formats
                if (/\.json($|\?)/.test(url.toLowerCase()) || url.includes('jsonplaceholder')) {
                    return 'json';
                }
                
                // Check for fonts
                if (/\.(woff2?|ttf|otf|eot)($|\?)/.test(url.toLowerCase())) {
                    return 'font';
                }
                
                // Check for media
                if (/\.(mp3|wav|ogg|flac)($|\?)/.test(url.toLowerCase())) return 'audio';
                if (/\.(mp4|webm|ogv)($|\?)/.test(url.toLowerCase())) return 'video';
                
                // API endpoints often return JSON
                if (url.includes('/api/')) return 'json';
                
                // Default
                return 'other';
            } catch (e) {
                return 'unknown';
            }
        }

        // Create a performance observer to track resource timing
        const observeNetworkRequests = () => {
            if (typeof PerformanceObserver === 'undefined') {
                console.warn('[iframe] PerformanceObserver not supported in this browser');
                return;
            }
            
            try {
                const observer = new PerformanceObserver((list) => {
                    for (const entry of list.getEntries()) {
                        if (entry.entryType === 'resource') {
                            // Some browsers don't properly report transferSize
                            // We'll enhance this with our manual tracking for fetch requests
                            const request = {
                                url: entry.name,
                                path: entry.name, // Use full URL as path
                                initiatorType: entry.initiatorType,
                                duration: Math.round(entry.duration * 100) / 100,
                                size: entry.transferSize || entry.decodedBodySize || 0,
                                timestamp: new Date().toISOString(),
                                startTime: entry.startTime,
                                responseEnd: entry.responseEnd,
                                type: detectContentType(entry.name, null, entry.initiatorType) // Use initiatorType directly
                            };
                            
                            // Update size if we have a manually tracked one (for fetch requests)
                            if (manuallyTrackedRequests[entry.name]) {
                                request.size = manuallyTrackedRequests[entry.name].size;
                                request.method = manuallyTrackedRequests[entry.name].method;
                                // Remove from tracked requests as it's now been merged with the PerformanceEntry
                                delete manuallyTrackedRequests[entry.name];
                            }
                            
                            console.log('[Network Tracking] Resource captured:', request.url, 'Type:', request.type, 'Initiator:', entry.initiatorType);
                            
                            networkRequests.push(request);
                            
                            // Send to parent if recording is active
                            if (isRecording) {
                                window.parent.postMessage({
                                    type: 'networkRequest',
                                    request: request
                                }, parentOrigin);
                            }
                        }
                    }
                });
                
                observer.observe({ entryTypes: ['resource'] });
                return observer;
            } catch (e) {
                console.error('[iframe] Error setting up PerformanceObserver:', e);
                return null;
            }
        };
        
        let networkObserver = null;

        // Function to intercept network requests
        function interceptNetworkRequests() {
            // Don't intercept if already intercepted
            if (originalXHROpen !== null) return;
            
            console.log('[iframe] Setting up network request interception');
            
            // Intercept XMLHttpRequest
            originalXHROpen = XMLHttpRequest.prototype.open;
            originalXHRSend = XMLHttpRequest.prototype.send;
            originalXHRSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
            
            // Override open method to capture request details
            XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
                this._requestMethod = method;
                this._requestUrl = url;
                this._requestHeaders = {};
                this._requestStartTime = performance.now();
                this._requestId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                
                // Call original method
                originalXHROpen.apply(this, arguments);
            };
            
            // Override setRequestHeader to capture headers
            XMLHttpRequest.prototype.setRequestHeader = function(name, value) {
                if (!this._requestHeaders) {
                    this._requestHeaders = {};
                }
                this._requestHeaders[name] = value;
                originalXHRSetRequestHeader.apply(this, arguments);
            };
            
            // Override send method to capture request body and response
            XMLHttpRequest.prototype.send = function(body) {
                const xhr = this;
                
                // Store request body if any
                if (body) {
                    xhr._requestBody = body;
                }
                
                // Function to extract response details safely
                function captureResponse() {
                    const endTime = performance.now();
                    const duration = endTime - xhr._requestStartTime;
                    
                    // Get URL path
                    let path = '';
                    try {
                        const urlObj = new URL(xhr._requestUrl);
                        path = urlObj.pathname + urlObj.search + urlObj.hash;
                    } catch (e) {
                        path = xhr._requestUrl;
                    }
                    
                    // Get response headers
                    const headers = {};
                    try {
                        const headersText = xhr.getAllResponseHeaders();
                        const headerLines = headersText.trim().split(/[\r\n]+/);
                        
                        headerLines.forEach(line => {
                            const parts = line.split(': ');
                            const name = parts.shift();
                            const value = parts.join(': ');
                            headers[name] = value;
                        });
                    } catch (e) {
                        console.warn('[iframe] Error parsing response headers:', e);
                    }
                    
                    // Get response size
                    let size = 0;
                    try {
                        if (xhr.responseType === '' || xhr.responseType === 'text') {
                            size = xhr.responseText ? xhr.responseText.length : 0;
                        } else if (xhr.response) {
                            // For other response types, try to get size from headers or estimate
                            const contentLength = headers['content-length'] || headers['Content-Length'];
                            if (contentLength) {
                                size = parseInt(contentLength, 10) || 0;
                            } else if (typeof xhr.response === 'string') {
                                size = xhr.response.length;
                            } else if (xhr.response instanceof ArrayBuffer) {
                                size = xhr.response.byteLength;
                            } else if (xhr.response instanceof Blob) {
                                size = xhr.response.size;
                            }
                        }
                    } catch (e) {
                        console.warn('[iframe] Error calculating response size:', e);
                    }
                    
                    // Create request object
                    const request = {
                        id: xhr._requestId,
                        url: xhr._requestUrl,
                        path: path,
                        method: xhr._requestMethod,
                        initiatorType: 'xhr',
                        startTime: xhr._requestStartTime,
                        endTime: endTime,
                        duration: Math.round(duration * 100) / 100,
                        status: xhr.status,
                        statusText: xhr.statusText,
                        headers: headers,
                        size: size,
                        timestamp: new Date().toISOString(),
                        type: detectContentType(xhr._requestUrl, headers, 'xmlhttprequest') // Use proper initiatorType
                    };
                    
                    // Add to network requests array
                    networkRequests.push(request);
                    
                    // Send to parent if recording
                    if (isRecording) {
                        window.parent.postMessage({
                            type: 'networkRequest',
                            request: request
                        }, parentOrigin);
                    }
                }
                
                // Attach event listeners to capture response
                xhr.addEventListener('load', captureResponse);
                xhr.addEventListener('error', captureResponse);
                xhr.addEventListener('abort', captureResponse);
                
                // Call original send method
                originalXHRSend.apply(this, arguments);
            };
            
            // Intercept Fetch API
            originalFetch = window.fetch;
            
            window.fetch = function(resource, init) {
                const requestStartTime = performance.now();
                const requestId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                
                // Extract request details
                let url = '';
                let method = 'GET';
                let headers = {};
                
                if (typeof resource === 'string') {
                    url = resource;
                } else if (resource instanceof Request) {
                    url = resource.url;
                    method = resource.method || 'GET';
                    
                    // Try to extract headers from Request object
                    try {
                        resource.headers.forEach((value, name) => {
                            headers[name] = value;
                        });
                    } catch (e) {
                        console.warn('[iframe] Error extracting headers from Request:', e);
                    }
                }
                
                // If init object provided, override defaults
                if (init) {
                    if (init.method) {
                        method = init.method;
                    }
                    
                    // Merge headers from init object
                    if (init.headers) {
                        if (init.headers instanceof Headers) {
                            try {
                                init.headers.forEach((value, name) => {
                                    headers[name] = value;
                                });
                            } catch (e) {
                                console.warn('[iframe] Error extracting headers from init.headers:', e);
                            }
                        } else if (typeof init.headers === 'object') {
                            Object.entries(init.headers).forEach(([name, value]) => {
                                headers[name] = value;
                            });
                        }
                    }
                }
                
                // Call original fetch
                return originalFetch.apply(this, arguments)
                    .then(response => {
                        const endTime = performance.now();
                        const duration = endTime - requestStartTime;
                        
                        // Clone response to avoid consuming it
                        const clonedResponse = response.clone();
                        
                        // Extract path from URL
                        let path = '';
                        try {
                            const urlObj = new URL(url);
                            path = urlObj.pathname + urlObj.search + urlObj.hash;
                        } catch (e) {
                            path = url;
                        }
                        
                        // Extract response headers
                        const responseHeaders = {};
                        try {
                            clonedResponse.headers.forEach((value, name) => {
                                responseHeaders[name] = value;
                            });
                        } catch (e) {
                            console.warn('[iframe] Error extracting response headers:', e);
                        }
                        
                        // Create request info object
                        const requestInfo = {
                            id: requestId,
                            url: url,
                            path: path,
                            method: method,
                            initiatorType: 'fetch',
                            startTime: requestStartTime,
                            endTime: endTime,
                            duration: Math.round(duration * 100) / 100,
                            status: clonedResponse.status,
                            statusText: clonedResponse.statusText,
                            requestHeaders: headers,
                            responseHeaders: responseHeaders,
                            timestamp: new Date().toISOString(),
                            type: detectContentType(url, responseHeaders, 'fetch') // Use proper initiatorType
                        };
                        
                        // Try to get response size from headers or by reading the response
                        const contentLength = responseHeaders['content-length'] || responseHeaders['Content-Length'];
                        
                        if (contentLength) {
                            requestInfo.size = parseInt(contentLength, 10) || 0;
                            
                            // Add to network requests and send immediately
                            networkRequests.push(requestInfo);
                            
                            if (isRecording) {
                                window.parent.postMessage({
                                    type: 'networkRequest',
                                    request: requestInfo
                                }, parentOrigin);
                            }
                            
                            return response;
                        }
                        
                        // If no content-length header, try to get size from response
                        return clonedResponse.text()
                            .then(text => {
                                requestInfo.size = text ? text.length : 0;
                                
                                // Add to network requests
                                networkRequests.push(requestInfo);
                                
                                // Send to parent if recording
                                if (isRecording) {
                                    window.parent.postMessage({
                                        type: 'networkRequest',
                                        request: requestInfo
                                    }, parentOrigin);
                                }
                                
                                return response;
                            })
                            .catch(error => {
                                console.warn('[iframe] Error getting response text:', error);
                                requestInfo.size = 0;
                                
                                // Add to network requests even if we couldn't get the size
                                networkRequests.push(requestInfo);
                                
                                if (isRecording) {
                                    window.parent.postMessage({
                                        type: 'networkRequest',
                                        request: requestInfo
                                    }, parentOrigin);
                                }
                                
                                return response;
                            });
                    })
                    .catch(error => {
                        // Capture errors during fetch
                        const endTime = performance.now();
                        const duration = endTime - requestStartTime;
                        
                        // Create error request info
                        const errorRequestInfo = {
                            id: requestId,
                            url: url,
                            method: method,
                            initiatorType: 'fetch',
                            startTime: requestStartTime,
                            endTime: endTime,
                            duration: Math.round(duration * 100) / 100,
                            status: 0,
                            statusText: 'Error',
                            error: error.message,
                            timestamp: new Date().toISOString(),
                            type: detectContentType(url, null, 'fetch') // Use proper initiatorType
                        };
                        
                        // Add to network requests
                        networkRequests.push(errorRequestInfo);
                        
                        // Send to parent if recording
                        if (isRecording) {
                            window.parent.postMessage({
                                type: 'networkRequest',
                                request: errorRequestInfo
                            }, parentOrigin);
                        }
                        
                        // Re-throw error for normal application flow
                        throw error;
                    });
            };
            
            return true;
        }

        // Function to restore original network methods
        function restoreNetworkInterception() {
            if (originalXHROpen === null) return;
            
            console.log('[iframe] Restoring original network methods');
            
            // Restore XMLHttpRequest methods
            XMLHttpRequest.prototype.open = originalXHROpen;
            XMLHttpRequest.prototype.send = originalXHRSend;
            XMLHttpRequest.prototype.setRequestHeader = originalXHRSetRequestHeader;
            
            // Restore fetch
            window.fetch = originalFetch;
            
            // Reset original method references
            originalXHROpen = null;
            originalXHRSend = null;
            originalXHRSetRequestHeader = null;
            originalFetch = null;
        }

        // Function called by parent to START recording
        window.startRecordingInIframe = () => { 
            msgDiv.textContent = 'Recording started by parent.';
            console.log('[iframe] startRecordingInIframe called.');
            
            // Enable console capture
            isRecording = true;
            overrideConsole();
            
            // Start network request recording
            networkRequests = [];
            
            // Set up network interception
            interceptNetworkRequests();
            
            // Set up Performance observer for resource timing
            if (!networkObserver) {
                networkObserver = observeNetworkRequests();
            }
            
            if (typeof window.rrweb === 'undefined' || typeof window.rrweb.record !== 'function') {
                console.error('[iframe] rrweb.record is not available!');
                window.parent.postMessage({ type: 'statusUpdate', text: 'Error: rrweb lib missing in iframe' }, parentOrigin);
                return;
            }
            
            // Stop previous recording if any
            if (typeof iframeStopFn === 'function') {
                try { iframeStopFn(); } catch(e) { console.warn('[iframe] Error stopping previous recording:', e); }
            }

            try {
                iframeStopFn = window.rrweb.record({
                    emit(event, isCheckout) {
                        // Send recorded event back to the parent window
                        window.parent.postMessage({ type: 'rrwebEvent', event: event, isCheckout: isCheckout }, parentOrigin);
                    },
                    maskAllInputs: false,
                    checkoutEveryNth: 100, // Example: Take full snapshot every 100 events
                    ignoreCSSAttributes: true, // Ignore CSS attributes to prevent CORS issues
                    blockClass: 'rrweb-block', // Add a class name to exclude elements
                    ignoreClass: 'rrweb-ignore', // Add a class name to exclude elements
                    inlineStylesheet: true, // Keep stylesheets inline to avoid CORS issues
                    recordCanvas: true,
                    recordLog: true, // Enable console log recording
                    logOptions: {
                        level: ['info', 'log', 'warn', 'error'],
                        lengthThreshold: 1000, // Max length of logged content
                    },
                    hooks: {
                        // Hook that disables stylesheet access to prevent CORS issues
                        afterSnapshot: (snapshot) => {
                            // Process snapshot to remove any cross-origin stylesheet references
                            if (snapshot && snapshot.storage && snapshot.storage.styleSheetRules) {
                                for (const key in snapshot.storage.styleSheetRules) {
                                    if (key.includes('cross-origin') || key.includes('SecurityError')) {
                                        delete snapshot.storage.styleSheetRules[key];
                                    }
                                }
                            }
                            return snapshot;
                        }
                    }
                });
                console.log('[iframe] rrweb recording started.');
                if (!iframeStopFn) {
                     console.error('[iframe] rrweb.record did not return a stop function!');
                     window.parent.postMessage({ type: 'statusUpdate', text: 'Error: rrweb.record failed in iframe' }, parentOrigin);
                }
            } catch (err) {
                 console.error('[iframe] Error starting rrweb recording:', err);
                 const errorPrefix = 'Error starting recording in iframe: ';
                 const errorMessage = err instanceof Error ? err.message : String(err);
                 window.parent.postMessage({ type: 'statusUpdate', text: errorPrefix + errorMessage }, parentOrigin); 
            }
        };

        // Function called by parent to STOP recording
        window.stopRecordingInIframe = () => { 
            msgDiv.textContent = 'Recording stopped by parent.';
            console.log('[iframe] stopRecordingInIframe called.');
            
            // Disable console capture
            isRecording = false;
            restoreConsole();
            
            // Restore original network methods
            restoreNetworkInterception();
            
            // Send final network request data
            window.parent.postMessage({
                type: 'allNetworkRequests',
                requests: networkRequests
            }, parentOrigin);
            
            if (typeof iframeStopFn === 'function') {
                try {
                    iframeStopFn();
                    console.log('[iframe] rrweb recording stopped.');
                    iframeStopFn = undefined;
                } catch (err) {
                    console.error('[iframe] Error calling iframeStopFn:', err);
                }
            } else {
                console.warn('[iframe] iframeStopFn not found or not a function when trying to stop.');
            }
        };

        // --- Communication with Parent --- 

        // Function to check if rrweb is ready and notify parent
        function notifyParentWhenReady() {
            let checkCount = 0;
            const maxChecks = 50; // Try for 5 seconds (50 * 100ms)
            const intervalId = setInterval(() => {
                checkCount++;
                if (typeof window.rrweb !== 'undefined' && typeof window.rrweb.record === 'function') {
                    clearInterval(intervalId);
                    console.log('[iframe] rrweb library confirmed ready. Notifying parent.');
                    window.parent.postMessage({ type: 'iframeReady' }, parentOrigin);
                    msgDiv.textContent = 'Ready for recording commands.';
                } else if (checkCount >= maxChecks) {
                    clearInterval(intervalId);
                    console.error('[iframe] rrweb library failed to load after timeout.');
                    window.parent.postMessage({ type: 'statusUpdate', text: 'Error: rrweb lib timeout in iframe' }, parentOrigin);
                    msgDiv.textContent = 'Error: Could not load recorder library.';
                }
            }, 100); // Check every 100ms
        }

        // Call the check function once the initial script runs
        // It will delay the iframeReady message until rrweb is loaded
        notifyParentWhenReady();
        
        // Network request functionality
        fetchButton.addEventListener('click', () => {
            makeNetworkRequest();
        });

        // Example button handlers
        exampleButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const url = e.target.getAttribute('data-url');
                if (url) {
                    urlInput.value = url;
                    makeNetworkRequest();
                }
            });
        });

        function makeNetworkRequest() {
            const url = urlInput.value.trim();
            const method = methodSelect.value;
            
            if (!url) {
                console.error('URL is required for network request');
                msgDiv.textContent = 'Error: URL is required';
                return;
            }
            
            msgDiv.textContent = `Making ${method} request to: ${url}`;
            console.log(`Initiating ${method} fetch to: ${url}`);
            
            fetch(url, { method })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    console.log(`Network response received: ${response.status}`);
                    
                    // Store the status code
                    const statusCode = response.status;
                    
                    // Clone the response for size calculation
                    const clone = response.clone();
                    return response.json().then(data => {
                        // Get the actual response text to measure accurate size
                        return clone.text().then(text => {
                            // Track the request size manually
                            const requestSize = new Blob([text]).size;
                            console.log(`Response size for ${url}: ${requestSize} bytes`);
                            
                            // Get URL path
                            const urlObj = new URL(url);
                            const path = urlObj.pathname + urlObj.search + urlObj.hash;
                            
                            // Store in our manual tracking
                            manuallyTrackedRequests[url] = {
                                size: requestSize,
                                method: method,
                                statusCode: statusCode,
                                path: path
                            };
                            
                            // Create a network request object
                            const requestObj = {
                                url: url,
                                path: path,
                                initiatorType: 'fetch',
                                method: method,
                                statusCode: statusCode,
                                duration: 0, // Will be updated by PerformanceObserver
                                size: requestSize,
                                timestamp: new Date().toISOString(),
                                type: detectContentType(url, {'content-type': response.headers.get('content-type')}, 'fetch') // Use proper initiatorType
                            };
                            
                            // Immediately send to parent if recording
                            if (isRecording) {
                                window.parent.postMessage({
                                    type: 'networkRequest',
                                    request: requestObj
                                }, parentOrigin);
                            }
                            
                            return data;
                        });
                    });
                })
                .then(data => {
                    console.log('Response data:', data);
                    const dataSize = JSON.stringify(data).length;
                    msgDiv.textContent = `Request successful! Received ${dataSize} bytes`;
                })
                .catch(error => {
                    console.error('Fetch error:', error);
                    msgDiv.textContent = `Error: ${error.message}`;
                });
        }

        // Track user interactions
        const userInteractions = [];
        function trackUserInteraction(event) {
            if (!isRecording) return;
            
            // Create a simplified version of the event
            // ... existing code ...
        }

        // Test different request methods
        document.getElementById('test-xhr-btn')?.addEventListener('click', () => {
            testXhrRequest();
        });
        
        document.getElementById('test-fetch-btn')?.addEventListener('click', () => {
            testFetchRequest();
        });
        
        document.getElementById('test-image-btn')?.addEventListener('click', () => {
            testImageLoad();
        });
        
        document.getElementById('test-all-btn')?.addEventListener('click', () => {
            testAllMethods();
        });
        
        function testXhrRequest() {
            const xhr = new XMLHttpRequest();
            xhr.open('GET', 'https://jsonplaceholder.typicode.com/todos/2');
            xhr.onload = function() {
                if (xhr.status === 200) {
                    console.log('XHR request successful:', JSON.parse(xhr.responseText));
                    msgDiv.textContent = 'XHR request completed successfully';
                } else {
                    console.error('XHR request failed:', xhr.status);
                    msgDiv.textContent = `XHR request failed: ${xhr.status}`;
                }
            };
            xhr.onerror = function() {
                console.error('XHR request error');
                msgDiv.textContent = 'XHR request error';
            };
            xhr.send();
            msgDiv.textContent = 'XHR request sent...';
        }
        
        function testFetchRequest() {
            fetch('https://jsonplaceholder.typicode.com/todos/3')
                .then(response => response.json())
                .then(data => {
                    console.log('Fetch request successful:', data);
                    msgDiv.textContent = 'Fetch request completed successfully';
                })
                .catch(error => {
                    console.error('Fetch request error:', error);
                    msgDiv.textContent = `Fetch request error: ${error.message}`;
                });
            msgDiv.textContent = 'Fetch request sent...';
        }
        
        function testImageLoad() {
            // Create a container for the image
            const container = document.createElement('div');
            container.style.margin = '10px 0';
            container.style.padding = '10px';
            container.style.border = '1px solid #ccc';
            container.style.borderRadius = '5px';
            container.style.backgroundColor = '#f8f8f8';
            container.style.textAlign = 'center';
            
            // Create title
            const title = document.createElement('h3');
            title.textContent = 'Google Logo';
            title.style.fontSize = '14px';
            title.style.margin = '0 0 10px 0';
            container.appendChild(title);
            
            // Create the image element
            const img = new Image();
            img.alt = 'Google Logo';
            img.style.maxWidth = '100%';
            img.style.height = 'auto';
            
            // Add loading and loaded status
            const status = document.createElement('p');
            status.textContent = 'Loading image...';
            status.style.fontSize = '12px';
            status.style.margin = '10px 0 0 0';
            container.appendChild(status);
            
            // Add information about the initiatorType
            const initiatorInfo = document.createElement('p');
            initiatorInfo.textContent = 'This image request will have initiatorType="img"';
            initiatorInfo.style.fontSize = '11px';
            initiatorInfo.style.opacity = '0.7';
            initiatorInfo.style.margin = '5px 0 0 0';
            container.appendChild(initiatorInfo);
            
            // Handle successful load
            img.onload = function() {
                console.log('Google logo loaded successfully');
                status.textContent = 'Image loaded successfully';
                status.style.color = 'green';
                msgDiv.textContent = 'Google logo appended to DOM and loaded successfully';
            };
            
            // Handle load error
            img.onerror = function(e) {
                console.error('Google logo load error:', e.type);
                status.textContent = 'Error loading image: ' + e.type;
                status.style.color = 'red';
            };
            
            // Set crossOrigin to anonymous to avoid CORS issues
            img.crossOrigin = 'anonymous';
            
            // Add a timestamp to prevent caching
            const timestamp = new Date().getTime();
            img.src = `https://picsum.photos/200/100`;
            
            // Add the image to the container
            container.appendChild(img);
            
            // Append the container to the document
            document.body.appendChild(container);
            
            // Update message
            msgDiv.textContent = 'Google logo appending to DOM...';
            
            // Return container so it can be referenced later if needed
            return container;
        }
        
        function testAllMethods() {
            testXhrRequest();
            setTimeout(testFetchRequest, 500);
            setTimeout(testImageLoad, 1000);
        }
    </script>
</body>
</html> 